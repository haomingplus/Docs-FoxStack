---
title: JVM深入解析
createTime: 2026-01-06 00:00:00
permalink: /jvm/jvm-memory-model/
---

# JVM 深入解析

## 一、JVM 概述

### 1.1 JVM 位置

```
┌─────────────────────────────────────────────────────────────────┐
│                        Java 体系结构                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐  │
│    │  Java SE     │     │  Java EE     │     │  Java ME     │  │
│    └──────┬───────┘     └──────┬───────┘     └──────┬───────┘  │
│           │                    │                     │          │
│           └────────────────────┴─────────────────────┘          │
│                            │                                    │
│                    ┌───────▼────────┐                          │
│                    │   JVM API       │                          │
│                    └───────┬────────┘                          │
│                            │                                    │
│    ┌───────────────────────▼─────────────────────────────┐     │
│    │                    JVM                              │     │
│    │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌────────┐  │     │
│    │  │类加载器  │  │  运行时  │  │ 垃圾回收 │  │执行引擎│  │     │
│    │  │         │  │  数据区  │  │         │  │        │  │     │
│    │  └─────────┘  └─────────┘  └─────────┘  └────────┘  │     │
│    └───────────────────────┬─────────────────────────────┘     │
│                            │                                    │
│                    ┌───────▼────────┐                          │
│                    │   操作系统       │                          │
│                    │   (OS)          │                          │
│                    └───────┬────────┘                          │
│                            │                                    │
│                    ┌───────▼────────┐                          │
│                    │   硬件         │                          │
│                    └────────────────┘                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

JVM 作用:
1. 屏蔽底层操作系统差异，实现 "一次编写，到处运行"
2. 提供内存管理和垃圾回收
3. 提供安全机制
```

### 1.2 JVM 架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        JVM 整体架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   类加载器子系统                          │   │
│  │  启动类加载 → 扩展类加载 → 应用类加载                     │   │
│  └────────────────────────┬────────────────────────────────┘   │
│                           │                                    │
│                           ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                     运行时数据区                          │   │
│  │  堆 | 方法区 | 栈 | PC | 本地方法栈                       │   │
│  └────────────────────────┬────────────────────────────────┘   │
│                           │                                    │
│                           ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   执行引擎                                │   │
│  │  ┌─────────────┐     ┌─────────────┐                     │   │
│  │  │ 解释器      │     │  JIT 编译器  │                     │   │
│  │  │ (Interpreter)│    │  (C1/C2)    │                     │   │
│  │  └─────────────┘     └─────────────┘                     │   │
│  │                                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │              GC (垃圾回收器)                     │    │   │
│  │  │   Serial | Parallel | CMS | G1 | ZGC | Shenandoah │   │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │         本地接口 (JNI) / 本地库                   │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 JVM 版本演进

| 版本 | 发布年份 | 重要特性 |
|------|----------|----------|
| JDK 1.0 | 1996 | 第一版 |
| JDK 1.2 | 1998 | 经典 JVM 架构确立 |
| JDK 1.4 | 2002 | 引入 NIO |
| JDK 5 | 2004 | 泛型、枚举、自动装箱 |
| JDK 6 | 2006 | 性能优化、动态语言支持 |
| JDK 7 | 2011 | invokedynamic、Try-with-resources |
| JDK 8 | 2014 | Lambda、Stream、永久代→元空间 |
| JDK 11 | 2018 | LTS 版本、ZGC |
| JDK 17 | 2021 | LTS 版本、密封类 |
| JDK 21 | 2023 | LTS 版本、虚拟线程 |

---

## 二、类加载机制

### 2.1 类加载过程

```
┌─────────────────────────────────────────────────────────────────┐
│                       类加载完整流程                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  .class 文件                                                     │
│      │                                                          │
│      ▼                                                          │
│  ┌─────────────────┐                                            │
│  │   1. 加载       │  ←─ 通过类全限定名获取二进制流              │
│  │   Loading       │  ←─ 转换为运行时方法区结构                  │
│  └────────┬────────┘  ←─ 创建 Class 对象                        │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │   2. 验证        │  ←─ 文件格式验证                          │
│  │   Verification   │  ←─ 字节码验证                            │
│  └────────┬────────┘  ←─ 符号引用验证                          │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │   3. 准备        │  ←─ 为类变量分配内存                      │
│  │   Preparation   │  ←─ 设置初始值 (零值)                      │
│  │                  │  ←─ final static 直接赋值                 │
│  │  示例:           │                                            │
│  │  public static int a = 10;  → a = 0                         │
│  │  public static final int b = 10; → b = 10                   │
│  └────────┬────────┘                                            │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │   4. 解析        │  ←─ 符号引用 → 直接引用                    │
│  │   Resolution    │  ←─ 类、接口、字段、方法解析               │
│  └────────┬────────┘                                            │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │   5. 初始化      │  ←─ 执行 <clinit> 方法                    │
│  │   Initialization │  ←─ 赋值真正代码中的值                    │
│  │                  │  ←─ 执行静态代码块                        │
│  │  public static int a = 10;  → a = 10                        │
│  └─────────────────┘                                            │
│           │                                                      │
│           ▼                                                      │
│      类加载完成                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 双亲委派模型

```java
// 双亲委派模型结构
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│                    Bootstrap ClassLoader                        │
│                    (启动类加载器 / C++ 实现)                     │
│                    加载: JAVA_HOME/lib/rt.jar                  │
│                              │                                  │
│                              ▼                                  │
│                 Extension ClassLoader                          │
│                 (扩展类加载器 / Java 实现)                      │
│                 加载: JAVA_HOME/lib/ext/*.jar                  │
│                              │                                  │
│                              ▼                                  │
│                Application ClassLoader                         │
│                (应用类加载器 / Java 实现)                       │
│                加载: 用户类路径 (classpath)                     │
│                              │                                  │
│                              ▼                                  │
│              自定义类加载器 (Custom ClassLoader)                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 双亲委派工作原理

```java
// ClassLoader.java
protected Class<?> loadClass(String name, boolean resolve) {
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查类是否已加载
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // 2. 委派给父加载器
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 父加载器无法加载
            }

            if (c == null) {
                // 3. 父加载器都找不到，自己尝试加载
                c = findClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

### 2.4 为什么需要双亲委派？

```
1. 安全性
   - 防止核心类被替换
   - 用户自定义 java.lang.String 无法加载

2. 避免重复加载
   - 类只需加载一次
   - 父加载器已加载则直接使用

3. 层次清晰
   - 层级关系明确
   - 保证 Java 核心类库安全
```

### 2.5 打破双亲委派

```java
// 需要打破双亲委派的场景:

// 1. SPI 机制 (如 JDBC)
// 接口定义在 rt.jar (启动类加载器)
// 实现由厂商提供 (应用类加载器)
// 需要父加载器委托子加载器加载

// 2. Tomcat 类加载机制
// 多个 Web 应用依赖不同版本类库
// 各个 WebAppClassLoader 隔离
// 优先加载自己的类，再委托父加载器

// 3. OSGi 热部署
// 每个模块 (Bundle) 独立类加载器
// 支持模块热插拔

// 自定义类加载器示例
public class CustomClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = loadClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        }
        return defineClass(name, classData, 0, classData.length);
    }

    private byte[] loadClassData(String name) {
        // 从指定位置加载字节码
        // 例如: 网络、文件、加密文件等
        return null;
    }
}
```

---

## 三、字节码与执行引擎

### 3.1 字节码文件结构

```
.class 文件结构 (伪代码展示)
┌─────────────────────────────────────────────────────────────────┐
│  ClassFile {                                                    │
│      u4             magic;           // 魔数 0xCAFEBABE         │
│      u2             minor_version;    // 次版本号               │
│      u2             major_version;    // 主版本号               │
│      u2             constant_pool_count;                         │
│      cp_info        constant_pool[constant_pool_count - 1];     │
│      u2             access_flags;     // 访问标志               │
│      u2             this_class;       // 当前类                 │
│      u2             super_class;      // 父类                   │
│      u2             interfaces_count;                          │
│      u2             interfaces[interfaces_count];               │
│      u2             fields_count;                               │
│      field_info     fields[fields_count];                       │
│      u2             methods_count;                              │
│      method_info    methods[methods_count];                     │
│      u2             attributes_count;                           │
│      attribute_info attributes[attributes_count];               │
│  }                                                              │
└─────────────────────────────────────────────────────────────────┘

使用 javap 查看字节码:
javap -v MyClass.class
javap -c MyClass.class  # 查看代码
```

### 3.2 字节码指令

```java
// 源代码
public class ByteCodeDemo {
    public int add(int a, int b) {
        return a + b;
    }
}

// 字节码 (javap -c)
 0: iload_1     // 将局部变量表索引 1 的 int 压入操作数栈
 1: iload_2     // 将局部变量表索引 2 的 int 压入操作数栈
 2: iadd        // 从操作数栈弹出两个 int 相加，结果压栈
 3: ireturn     // 返回操作数栈顶部的 int

// 操作数栈变化:
// iload_1: [空] -> [a]
// iload_2: [a] -> [a, b]
// iadd:    [a, b] -> [a+b]
// ireturn: [a+b] -> [空]
```

### 3.3 执行引擎架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        执行引擎                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    字节码解释器                           │   │
│  │                                                          │   │
│  │   逐条解释执行字节码 → 机器码                             │   │
│  │   优点: 启动快、解释执行快                                │   │
│  │   缺点: 执行效率低                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↕                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                 JIT 编译器 (即时编译)                     │   │
│  │                                                          │   │
│  │   ┌─────────────────┐     ┌─────────────────┐            │   │
│  │   │  C1 编译器       │     │   C2 编译器      │            │   │
│  │   │  (Client 编译器)  │     │   (Server 编译器) │            │   │
│  │   │                  │     │                  │            │   │
│  │   │  - 简单优化       │     │  - 激进优化        │            │   │
│  │   │  - 编译时间短    │     │  - 编译时间长     │            │   │
│  │   │  - C1 Level 1-3  │     │  - C2 Level 4     │            │   │
│  │   └─────────────────┘     └─────────────────┘            │   │
│  │                                                          │   │
│  │   热点代码探测: 方法调用次数 + 回边次数达到阈值            │   │
│  │   热点代码 → 编译为本地代码 → 缓存到 Code Cache            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    AOT 编译 (Graal)                       │   │
│  │                                                          │   │
│  │   提前编译: .class → 本地代码                            │   │
│  │   启动快，但优化有限                                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 分层编译

```
分层编译 (Tiered Compilation) - JDK 7+ 默认开启

┌─────────────────────────────────────────────────────────────────┐
│  Level 0: 解释执行                                               │
│          └── 方法进入，先解释执行                                │
│                 ↓                                               │
│  Level 1: C1 编译 (不带 profiling)                               │
│          └── 简单编译，收集基本信息                               │
│                 ↓                                               │
│  Level 2: C1 编译 (带有限 profiling)                             │
│          └── 收集更多统计信息                                    │
│                 ↓                                               │
│  Level 3: C1 编译 (带完全 profiling)                             │
│          └── 完整收集分支、调用信息                               │
│                 ↓                                               │
│  Level 4: C2 编译 (激进优化)                                     │
│          └── 基于 profiling 信息进行激进优化                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

热点探测阈值:
-XX:CompileThreshold=10000  // C2 编译阈值 (默认)
-XX:Tier3CompileThreshold=2000  // C3 编译阈值
```

### 3.5 常见优化技术

```java
// 1. 方法内联 (Inlining)
public class InlineDemo {
    public int add(int a, int b) {
        return a + b;
    }

    public int compute(int x, int y) {
        // 内联前: 调用 add 方法
        // 内联后: return x + y;
        return add(x, y);
    }
}

// 2. 逃逸分析 (Escape Analysis)
public class EscapeAnalysisDemo {
    public void method() {
        // 对象未逃逸，可能栈上分配
        Object obj = new Object();
        obj.toString();
    }
}

// 3. 标量替换 (Scalar Replacement)
public void method() {
    // 原代码
    Point p = new Point(1, 2);
    System.out.println(p.x + p.y);

    // 标量替换后
    int x = 1;
    int y = 2;
    System.out.println(x + y);
}

// 4. 锁消除 (Lock Elimination)
public void lockElimination() {
    // StringBuffer 的 append 方法有 synchronized
    // 但 sb 是局部变量，未逃逸，锁可消除
    StringBuffer sb = new StringBuffer();
    sb.append("a").append("b");
}

// 5. 循环展开 (Loop Unrolling)
for (int i = 0; i < 4; i++) {
    sum += array[i];
}
// 展开后
sum += array[0];
sum += array[1];
sum += array[2];
sum += array[3];
```

---

## 四、垃圾回收机制

### 4.1 垃圾判定算法

```
┌─────────────────────────────────────────────────────────────────┐
│                   引用计数算法 (Reference Counting)              │
│                                                                  │
│  ┌──────┐       ┌──────┐                                        │
│  │ ObjA │ ────→ │ ObjB │  循环引用，无法回收                     │
│  └──────┘ ←──── └──────┘                                        │
│                                                                  │
│  优点: 简单、效率高                                               │
│  缺点: 无法解决循环引用                                           │
│  Python 使用此算法，配合循环引用检测                               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   可达性分析 (Reachability Analysis)             │
│                                                                  │
│  GC Roots:                                                       │
│  ┌──────────────────┐                                           │
│  │  虚拟机栈引用     │  ──┐                                       │
│  └──────────────────┘    │                                       │
│  ┌──────────────────┐    │                                       │
│  │  方法区静态引用   │  ──┼──→ 可达对象                           │
│  └──────────────────┘    │                                       │
│  ┌──────────────────┐    │                                       │
│  │  方法区常量引用   │  ──┘                                       │
│  └──────────────────┘    │                                       │
│  ┌──────────────────┐    │                                       │
│  │  JNI 本地引用     │  ──┘                                       │
│  └──────────────────┘                                           │
│                        │                                          │
│                        ▼                                          │
│  不可达对象 → 可回收 (至少标记两次)                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 引用类型

```java
// 1. 强引用 (Strong Reference)
Object obj = new Object();
// 只要引用存在，永不回收

// 2. 软引用 (SoftReference) - 内存不足时回收
SoftReference<byte[]> soft = new SoftReference<>(new byte[1024 * 1024]);
// 适用: 缓存

// 3. 弱引用 (WeakReference) - GC 发现即回收
WeakReference<Object> weak = new WeakReference<>(new Object());
// 适用: ThreadLocal、WeakHashMap

// 4. 虚引用 (PhantomReference) - 无法通过引用获取对象
ReferenceQueue<Object> queue = new ReferenceQueue<>();
PhantomReference<Object> phantom = new PhantomReference<>(new Object(), queue);
// 必须配合引用队列使用，用于跟踪对象回收状态

// 引用强度比较
强引用 > 软引用 > 弱引用 > 虚引用
```

### 4.3 垃圾收集算法

```
┌─────────────────────────────────────────────────────────────────┐
│                   标记-清除 (Mark-Sweep)                          │
│                                                                  │
│  标记前:  ┌───┬───┬───┬───┬───┬───┬───┬───┐                     │
│          │ A │ B │   │ D │   │ F │   │ H │                     │
│          └───┴───┴───┴───┴───┴───┴───┴───┘                     │
│                                                                  │
│  标记:    ●   ●       ●       ●       ●                         │
│                                                                  │
│  清除后:  ┌───┬───┬───┬───┬───┬───┬───┬───┐                     │
│          │ A │ B │   │ D │   │ F │   │ H │                     │
│          └───┴───┴───┴───┴───┴───┴───┴───┘                     │
│                                                                  │
│  优点: 简单                                                      │
│  缺点: 产生内存碎片                                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   标记-整理 (Mark-Compact)                        │
│                                                                  │
│  标记前:  ┌───┬───┬───┬───┬───┬───┬───┬───┐                     │
│          │ A │ B │   │ D │   │ F │   │ H │                     │
│          └───┴───┴───┴───┴───┴───┴───┴───┘                     │
│                                                                  │
│  整理后:  ┌───┬───┬───┬───┬───┬───┬───┬───┐                     │
│          │ A │ B │ D │ F │ H │   │   │   │                     │
│          └───┴───┴───┴───┴───┴───┴───┴───┘                     │
│                                                                  │
│  优点: 无内存碎片                                                │
│  缺点: 移动对象成本高                                            │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   复制 (Copying)                                  │
│                                                                  │
│  From:   ┌───┬───┬───┬───┐                                      │
│          │ A │   │ C │   │                                      │
│          └───┴───┴───┴───┘                                      │
│            │       │                                            │
│            ▼       ▼                                            │
│  To:     ┌───┬───┬───┬───┐                                      │
│          │ A │ C │   │   │                                      │
│          └───┴───┴───┴───┘                                      │
│                                                                  │
│  优点: 无内存碎片、简单                                          │
│  缺点: 内存利用率低 (HotSpot 8:1:1)                              │
└─────────────────────────────────────────────────────────────────┘
```

### 4.4 垃圾收集器

```
┌─────────────────────────────────────────────────────────────────┐
│                     垃圾收集器发展历程                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  新生代收集器: Serial │ ParNew │ Parallel Scavenge               │
│  老年代收集器: Serial Old │ CMS │ Parallel Old                   │
│  整堆收集器:   G1 │ ZGC │ Shenandoah                            │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Serial / Serial Old                                            │
│  ┌──────────────┐  ┌──────────────┐                            │
│  │   新生代      │  │   老年代      │                            │
│  │   Serial     │  │  Serial Old  │                            │
│  │   (复制)      │  │  (标记-整理)  │                            │
│  └──────────────┘  └──────────────┘                            │
│                                                                  │
│  特点: 单线程、STW、简单                                         │
│  适用: 客户端模式、小内存                                        │
│  参数: -XX:+UseSerialGC                                         │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ParNew / CMS (JDK 14 移除)                                     │
│  ┌──────────────┐  ┌──────────────┐                            │
│  │   新生代      │  │   老年代      │                            │
│  │   ParNew     │  │     CMS      │                            │
│  │   (多线程复制) │  │  (标记-清除)  │                            │
│  └──────────────┘  └──────────────┘                            │
│                                                                  │
│  特点: 低延迟、并发收集                                          │
│  适用: Web 应用、响应时间敏感                                    │
│  参数: -XX:+UseConcMarkSweepGC                                  │
│  问题: CPU 敏感、浮动垃圾、空间碎片                              │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Parallel Scavenge / Parallel Old (JDK 8 默认)                  │
│  ┌──────────────┐  ┌──────────────┐                            │
│  │   新生代      │  │   老年代      │                            │
│  │ Parallel     │  │ Parallel Old │                            │
│  │ Scavenge     │  │ (标记-整理)   │                            │
│  └──────────────┘  └──────────────┘                            │
│                                                                  │
│  特点: 多线程、关注吞吐量                                        │
│  适用: 后台计算、批处理                                          │
│  参数: -XX:+UseParallelGC                                       │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  G1 (Garbage First) - JDK 9 默认                                │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                                                          │  │
│  │  ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐    │  │
│  │  │ E  │ E  │ S  │ S  │ E  │ O  │ O  │ O  │ O  │ O  │    │  │
│  │  └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘    │  │
│  │                                                          │  │
│  │  E = Eden, S = Survivor, O = Old                         │  │
│  │                                                          │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  特点: Region 划分、可预测停顿、并发标记                         │
│  适用: 大堆 (4G+)、延迟可控                                      │
│  参数: -XX:+UseG1GC                                             │
│  目标: < 10ms pause time                                        │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ZGC (Z Garbage Collector) - JDK 15 生产可用                    │
│                                                                  │
│  特点: 并发整理、Region、读屏障、染色指针                         │
│  适用: 超大堆 (TB 级)、延迟 < 10ms                               │
│  参数: -XX:+UseZGC                                              │
│                                                                  │
│  停顿时间: < 1ms (JDK 17)                                       │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Shenandoah - OpenJDK 12                                        │
│                                                                  │
│  特点: 并发整理、Brooks Pointer                                  │
│  适用: 大堆、低延迟                                              │
│  参数: -XX:+UseShenandoahGC                                     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 4.5 GC 日志

```bash
# JDK 8 GC 日志参数
-XX:+PrintGC              # 打印 GC
-XX:+PrintGCDetails       # 打印 GC 详情
-XX:+PrintGCTimeStamps    # 打印 GC 时间戳
-XX:+PrintGCApplicationStoppedTime  # 打印 STW 时间
-Xloggc:/path/to/gc.log   # GC 日志文件

# JDK 9+ 统一日志
-Xlog:gc*:file=gc.log:time,uptime,level,tags

# 常用组合
-Xlog:gc*:gc.log:time,uptime,level,tags

# GC 日志示例分析
[GC (Allocation Failure) [PSYoungGen: 268800K->5120K(273920K)] 274375K->7244K(917504K), 0.0234512 secs] [Times: user=0.05 sys=0.01, real=0.02 secs]
 ↑                  ↑                           ↑                           ↑
 GC原因             新生代变化                   堆变化                    停顿时间
```

---

## 五、性能监控与调优

### 5.1 监控工具

```
┌─────────────────────────────────────────────────────────────────┐
│                        JVM 监控工具                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  命令行工具 (JDK bin 目录):                                       │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  jps    - 显示 Java 进程                                  │  │
│  │  jstat  - 监控统计信息 (类加载、编译、内存、GC)            │  │
│  │  jinfo  - 查看/修改 JVM 参数                              │  │
│  │  jmap   - 查看堆内存、dump 堆                             │  │
│  │  jstack - 查看线程栈                                      │  │
│  │  jcmd   - 多功能诊断工具 (JDK 7+)                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  可视化工具:                                                      │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  JConsole      - JDK 自带监控                             │  │
│  │  VisualVM      - JDK 自带，功能强大                       │  │
│  │  Mission Control - Oracle 官方 (JMC)                      │  │
│  │  Arthas        - 阿里开源 (线上诊断神器)                  │  │
│  │  JProfiler     - 商业工具                                 │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 常用命令示例

```bash
# jps - 查看进程
jps -l
# 12345 com.example.Main
# 12346 org.apache.catalina.startup.Bootstrap

# jstat - 实时监控
jstat -gc 12345 1s 10    # 每 1 秒输出一次，共 10 次
jstat -gcutil 12345      # 查看 GC 利用率

# jmap - 堆分析
jmap -heap 12345          # 查看堆配置
jmap -histo:live 12345    # 查看存活对象统计
jmap -dump:live,format=b,file=heap.hprof 12345  # 导出堆 dump

# jstack - 线程分析
jstack 12345              # 查看线程栈
jstack -l 12345           # 包含锁信息

# jinfo - 参数查看
jinfo -flags 12345        # 查看 JVM 参数
jinfo -flag UseG1GC 12345 # 查看特定参数

# jcmd - 多功能
jcmd 12345 VM.flags       # 查看 JVM 参数
jcmd 12345 GC.heap_info   # 查看堆信息
jcmd 12345 GC.run         # 建议 GC
jcmd 12345 Thread.print   # 打印线程信息
```

### 5.3 OOM 分析

```java
// 1. Java heap space - 堆内存不足
// 原因: 对象过多且无法回收、内存泄漏
// 排查: jmap -histo:live 找出大对象

// 2. Metaspace - 元空间不足
// 原因: 加载类过多 (动态代理、反射、大量 JSP)
// 排查: 调大 -XX:MaxMetaspaceSize

// 3. GC overhead limit exceeded
// 原因: GC 耗时过长 (98% 时间在 GC，回收 < 2%)
// 排查: 内存泄漏、堆太小

// 4. Direct buffer memory
// 原因: 直接内存不足 (NIO)
// 排查: 调大 -XX:MaxDirectMemorySize

// 5. Unable to create new native thread
// 原因: 线程数超过系统限制
// 排查: 调大 -Xss 或减少线程数

// 6. StackOverflowError
// 原因: 栈深度超过限制 (递归过深)
// 排查: 检查递归代码、调大 -Xss
```

### 5.4 CPU 高问题排查

```bash
# 1. 找到 CPU 高的 Java 进程
top
# PID   %CPU
# 12345 300.0

# 2. 找到 CPU 高的线程
top -Hp 12345
# PID   %CPU
# 12346  100.0
# 12347  100.0

# 3. 线程 ID 转 16 进制 (用于匹配 jstack 输出)
printf "%x\n" 12346
# 303a

# 4. 查看线程栈
jstack 12345 | grep -A 20 "303a"
# 找到对应线程的堆栈，定位代码
```

### 5.5 调优参数建议

```bash
# 堆内存设置
-Xms4g -Xmx4g              # 初始和最大堆相同，避免动态调整
-Xmn2g                     # 新生代大小

# 元空间
-XX:MetaspaceSize=256m     # 触发 GC 的阈值
-XX:MaxMetaspaceSize=512m  # 最大元空间

# GC 选择
-XX:+UseG1GC               # 推荐 G1 (大堆、低延迟)
# -XX:+UseZGC             # ZGC (超大堆、超低延迟)
# -XX:+UseParallelGC      # Parallel (高吞吐量)

# G1 参数
-XX:MaxGCPauseMillis=200  # 最大停顿时间目标
-XX:G1HeapRegionSize=16m  # Region 大小
-XX:InitiatingHeapOccupancyPercent=45  # 触发并发标记的堆占比

# 其他优化
-XX:+AlwaysPreTouch       # 启动时预分配内存
-XX:+UseStringDeduplication  # G1 字符串去重
-XX:+UseTLAB              # 线程本地分配缓冲
-XX:+DisableExplicitGC   # 禁用 System.gc()

# OOM 处理
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/var/log/heapdump.hprof
-XX:OnOutOfMemoryError="kill -9 %p"  # OOM 时自动杀死进程

# 日志
-Xlog:gc*:file=/var/log/gc.log:time,tags:filecount=5,filesize=100m
```

---

## 六、常见面试题

### Q1: 对象一定在堆上分配吗？

```java
// 不一定，JVM 有逃逸分析优化

public class EscapeAnalysis {
    // 1. 未逃逸对象可能栈上分配
    public void method1() {
        Object obj = new Object();  // 可能栈上分配
        obj.toString();
    }

    // 2. 标量替换
    public void method2() {
        int x = 1;
        int y = 2;
        // new Point(x, y) 可能被替换为标量
    }

    // 3. 大对象直接进老年代
    // -XX:PretenureSizeThreshold=3m
    Object bigObj = new byte[4 * 1024 * 1024];
}
```

### Q2: 为什么 Survivor 区有两个？

```
复制算法需要两个 Survivor 区:
1. GC 时，Eden + S0 → S1，然后清空 Eden 和 S0
2. 下一次 GC，Eden + S1 → S0

原因:
- 避免 S 区和 Eden 区数据混淆
- 确保 S 区总是有空的区域接收存活对象
- 实现 "复制后清空" 的简单逻辑
- 对象年龄统计更准确
```

### Q3: Major GC 和 Full GC 的区别？

```
Minor GC: 新生代 GC
Major GC: 老年代 GC (有些资料将 Major = Full)
Full GC:  整个堆 (新生代 + 老年代) + 方法区

触发 Full GC 的条件:
1. System.gc() (可配置 -XX:+DisableExplicitGC)
2. 老年代空间不足
3. 方法区空间不足
4. CMS GC 失败 (Concurrent mode failure)
5. 分配担保失败

Full GC 特点:
- 暂停时间长 (秒级甚至分钟级)
- 尽量避免频繁 Full GC
```

### Q4: G1 相比 CMS 的优势？

| 对比项 | CMS | G1 |
|--------|-----|-----|
| 内存布局 | 连续 | Region (不连续) |
| 停顿时间模型 | 无法预测 | 可预测 |
| 碎片问题 | 有 (标记-清除) | 无 (复制整理) |
| 适用范围 | JDK 14 移除 | 推荐 |
| 并发标记 | 是 | 是 |
| 并发整理 | 否 | 是 |

### Q5: 为什么 JDK 8 把永久代换成元空间？

```
1. 永久代大小固定，容易 OOM
   -PermSize=128m -MaxPermSize=256m

2. 类加载信息难以准确预估
   - 动态代理、反射、JSP

3. GC 复杂度
   - 需要扫描永久代

4. 元空间优势
   - 使用本地内存，受物理内存限制
   - 动态扩展
   - 更容易调优
```

### Q6: 类加载器的双亲委派模型是怎么实现的？

```java
// 核心逻辑:
protected Class<?> loadClass(String name, boolean resolve) {
    // 1. 检查已加载
    Class<?> c = findLoadedClass(name);
    if (c == null) {
        // 2. 委派父加载器
        if (parent != null) {
            c = parent.loadClass(name, false);
        } else {
            c = findBootstrapClassOrNull(name);
        }
        // 3. 父加载器找不到，自己加载
        if (c == null) {
            c = findClass(name);
        }
    }
    return c;
}

// 破坏双亲委派: 重写 loadClass 或使用线程上下文类加载器
```

### Q7: JVM 有哪些参数？

```bash
# 三类参数:
1. 标准参数 (- 开头，稳定)
   -version, -help, -cp, -classpath

2. X 参数 (-X 开头，非标准化)
   -Xms, -Xmx, -Xss

3. XX 参数 (-XX 开头，不稳定，用于调优)
   -XX:+PrintGC              # 布尔值
   -XX:MaxGCPauseMillis=200  # 数值
   -XX:HeapDumpPath=./dump   # 字符串

# 查看所有参数
java -XX:+PrintFlagsFinal -version
# = 表示默认值
# := 表示用户修改后的值
```

### Q8: 如何判断对象是否可以回收？

```
1. 引用计数法 (JVM 未采用)
   - 缺点: 循环引用问题

2. 可达性分析 (JVM 采用)
   - GC Roots 作为起点向下搜索
   - 不可达的对象 = 可回收

3. finalization 机制
   - 两次标记:
     1. 不可达 → 第一次标记
     2. 无 finalize 方法 或 已执行 → 可回收
   - 可复活: finalize 方法中重新关联到 GC Roots
```

---

## 七、总结

### JVM 知识体系

```
┌─────────────────────────────────────────────────────────────────┐
│                      JVM 知识全景图                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    类加载机制                             │   │
│  │  加载 → 验证 → 准备 → 解析 → 初始化                      │   │
│  │  双亲委派模型                                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                     │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    运行时数据区                           │   │
│  │  堆 | 方法区 | 栈 | PC | 本地方法栈                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                     │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    垃圾回收                               │   │
│  │  可达性分析 → 标记 → 清除/整理/复制                       │   │
│  │  Serial | Parallel | CMS | G1 | ZGC                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                     │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    执行引擎                               │   │
│  │  解释器 + JIT 编译器 (C1/C2)                              │   │
│  │  字节码 → 本地机器码                                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                     │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    性能调优                               │   │
│  │  监控 → 分析 → 调整参数 → 验证                            │   │
│  │  jps | jstat | jmap | jstack | Arthas                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 学习建议

| 阶段 | 内容 | 目标 |
|------|------|------|
| 入门 | 内存结构、GC 基本原理 | 理解 JVM 运行机制 |
| 进阶 | 类加载、字节码、GC 算法 | 能进行基础调优 |
| 高级 | JIT 优化、GC 原理、性能调优 | 深入理解 JVM |
| 专家 | 源码阅读、自定义 JVM | HotSpot 源码 |

### 推荐资源

- 《深入理解 Java 虚拟机》- 周志明
- 《Java 性能权威指南》- Scott Oaks
- OpenJDK 源码: http://openjdk.java.net/
- JVM 规范: https://docs.oracle.com/javase/specs/jvms/se8/html/
